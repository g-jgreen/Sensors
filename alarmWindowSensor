{
  "name": "alarmWindowSensor",
  "version": "1.0.1",
  "type": "sensor",
  "script": "var username =  options.globalSettings.API_KEY;\nvar password = options.globalSettings.API_PASS;\nvar domain = options.globalSettings.waylay_domain;\nconsole.log(\"domain\", domain)\nvar state = options.requiredProperties.state;\nvar thing = options.task.TASK_ID + \"_\" + options.requiredProperties.node;\nvar timeBeforeMillis = options.requiredProperties.windowMinutes * 60 * 1000;\nvar number = options.requiredProperties.number;\nvar now = moment();\n\nconsole.log(\"node\", options.requiredProperties.node);\n\nvar msg = waylayUtil.getRawData(options, options.requiredProperties.node);\nconsole.log(\"raw data:\", JSON.stringify(msg));\n\nmsg.collectedTime = now.unix() * 1000;\n\nvar consecutive = options.requiredProperties.consecutive;\nif(consecutive.toLowerCase() === \"true\")\n    consecutive = true\nelse\n    consecutive = false;\n\nvar reqOps = {\n    auth: {\n        user: username,\n        pass: password,\n        sendImmediately: true\n    }\n};\n\n//async store, no need to wait before sending result.\nvar storeMessage = function(msg, callback){\n    reqOps.url = \"https://data.waylay.io/resources/\"+ thing +\"?domain=\"+domain;\n    reqOps.json = msg;\n    try{\n        request.post(reqOps, function(error, response, body) {\n        if (!error && response.statusCode == 200) {\n            console.log(\"message stored \" + JSON.stringify(msg));\n            callback();\n        } else{\n            console.log(\"message rejected \" + error);\n            callback();\n        }\n        });\n    }catch(err){\n        callback();\n    }\n}\n\n\nif(thing && state && timeBeforeMillis ) {\n    reqOps.url = \"https://data.waylay.io/resources/\"+ thing +\"/series?domain=\"+domain;\n    request(reqOps, function (error, response, body) {\n      if (!error && response.statusCode == 200) {\n        console.log(body)\n        var data = JSON.parse(body);\n        //add the last one\n        data.push(msg)\n        \n        var filteredWindowData = _.filter(data, function(value){\n            return (value.collectedTime > now.unix() * 1000 - timeBeforeMillis);\n        });\n        var filteredStateData = _.filter(filteredWindowData, function(value){\n            return (value.collectedTime > now.unix() * 1000 - timeBeforeMillis) && value.state === state;\n        });\n\n        var returnState;\n        if(consecutive){\n            returnState = filteredStateData.length === filteredWindowData.length && filteredStateData.length > number? \"Alarm\" : \"No Alarm\"\n        } else {\n             returnState = filteredStateData.length > number? \"Alarm\" : \"No Alarm\"\n        }\n        var retValue = {\n            observedState : returnState,\n            rawData : {count :filteredStateData.length } \n        }\n        console.log(\"value \" + retValue);\n        storeMessage(msg, function() {send(null, retValue)})\n        }\n    else {\n        console.log(response)\n        storeMessage(msg, function() { send(new Error(response))});\n     }\n    }); \n} else{\n  send(new Error(\"Missing properties \"));\n}",
  "metadata": {
    "author": "",
    "category": "Experimental",
    "description": "Needs as the input node name, state of the node.\nit checks the number of time that node was in a given state for a given window of time. \nIf consecutive defined as true, it will also check that within a time window, all states are the same.",
    "iconURL": "https://dummyimage.com/160&text=alarmTestSensor",
    "supportedStates": [
      "Alarm",
      "No Alarm"
    ],
    "requiredProperties": [
      "node",
      "state",
      "windowMinutes",
      "number",
      "consecutive"
    ],
    "requiredRawData": [],
    "rawData": [
      {
        "parameter": "count",
        "dataType": "integer"
      }
    ]
  }
}
